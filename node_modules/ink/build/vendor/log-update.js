// Fork of `log-update` without `wrap-ansi` until https://github.com/chalk/wrap-ansi/issues/27 is closed
'use strict';

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const ansiEscapes = require('ansi-escapes');

const cliCursor = require('cli-cursor');

const main = (stream, options) => {
  options = _objectSpread({
    showCursor: false
  }, options);
  let prevLineCount = 0;

  const render = function () {
    if (!options.showCursor) {
      cliCursor.hide();
    }

    const out = [].join.call(arguments, ' ') + '\n'; // eslint-disable-line prefer-rest-params

    stream.write(ansiEscapes.eraseLines(prevLineCount) + out);
    prevLineCount = out.split('\n').length;
  };

  render.clear = () => {
    stream.write(ansiEscapes.eraseLines(prevLineCount));
    prevLineCount = 0;
  };

  render.done = () => {
    prevLineCount = 0;

    if (!options.showCursor) {
      cliCursor.show();
    }
  };

  return render;
};

module.exports = main(process.stdout);
module.exports.stderr = main(process.stderr);
module.exports.create = main;